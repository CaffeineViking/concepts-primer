\section{Generic Programming} \label{sec:generic_programming}

Ever since the humble beginnings of \Cpp\ there's been extensive support for different kinds of \emph{polymorphism}, which can be split into two ``main'' categories: \emph{run-time} polymorphism and \emph{compile-time} polymorphism. The former is a key component in class-based OOP, and takes the form of inheritance, while the latter one enables \emph{generic programming}, and is synonymous with \emph{templates}.

Templates are a bit special in \Cpp\ since they are \emph{unconstrained}. Meaning, when we \emph{instantiate} e.g. function templates, the compiler will first generate the function (that's the instantiation part) by replacing \texttt{T} with whatever type you've passed to the function, and only \underline{after}, check if the syntax is correct! This leads to some very unfortunate side-effects, as you'll see soon enough :)

But before digging into the gritty details on that, let's start with a simple example of ``regular programming'' (i.e. with no templates), which we'll then use to iteratively build a scenario where generic programming will be needed. This will help us understand the though process that goes into designing a generic function, and how \emph{requirements} are gathered by the function's author.

Below is a function that calculates the arithmetic mean by taking in two pointers to a C-style array of \texttt{doubles}, one for the first, and last elements. Notice, that even if we would mangle the names, we would still recognize this as the \texttt{mean}, since the operations (summing elements and dividing by size), would still be familiar to us, since we know what \texttt{\{\}}, \texttt{+=}, \texttt{/} do to \texttt{doubles}.

\lstinputlisting[linerange={3-10}]{examples/mean.cc}

\noindent By using \emph{operator overloading}, we can make our user-defined types behave just like built-in types. This is very powerful, because it allows us to transfer our knowledge about e.g. \texttt{doubles}, and apply it for our own types as well, by using the \underline{\emph{same syntax}} as before. This last part is particularly important!

\lstinputlisting[linerange={6-16}]{examples/point2.hh}

\lstinputlisting[linerange={5-12}]{examples/centroid.cc}



\noindent As can be seen above, providing all those overloads to \texttt{point2} proved fruitful, since we can now represent the algorithm to find the centroid of a cluster of points in a very natural way, quite similarly to how we did the \texttt{mean} function. In fact, this function is \emph{exactly} the same as \texttt{mean}, with the only difference being that the type \texttt{double} $\rightarrow$ \texttt{point2} and that now \texttt{mean} $\rightarrow$ \texttt{centroid}. Surely there must be a way to generalize this type of ``coincidence'' in \Cpp? If you've done any GP at all before, you probably know where this is going!

\vspace{1em}\noindent\textbf{Note:} these are \underline{not} good examples on how you should write these functions, for instance, what happens when \texttt{begin >= end}? And why use pointers? Many examples in this primer are like this too, so don't use it in production!

\subsection{Unconstrained Templates} \label{sec:unconstrained_templates}

    Obviously, both \texttt{mean} and \texttt{centroid} are trying to find an \texttt{average}, which we can express as a higher-level idea with \emph{function templates}, as shown below. We've essentially just swapped \texttt{double}/\texttt{point2} by \texttt{T}, a \emph{template parameter}. These are defined in \emph{template parameter lists}, which have either \emph{type} or \emph{non-type template parameters}. By default, template parameters are \emph{unconstrained}, which means they may take \emph{any} type or value (using non-type parameters).

    Now, assume you're a user of this function, and wish to use it with your own user-defined type. What are the \emph{requirements} our type needs to \emph{satisfy}? As authors of this function, we know \texttt{T} needs to be \texttt{DefaultConstructible} in line 4, \texttt{Summable} with \texttt{T} in line 7, and \texttt{Scalable} by \texttt{double} in line 8. However, the user doesn't know that, and there's no way to tell by looking at the function signature... Do we have to go and look at the implementation?

    While that might work for this short toy example, it certainly won't scale. A possible solution (adopted by the STL) is to document everything on paper.

    \lstinputlisting[linerange={7-7,11-18}]{examples/average.cc}

    While writing documentation for the requirements on \texttt{T} certainly works, there is no guarantee the user will read it. And even if the user \emph{does} read it, there is still the possibility he/she will implement the requirements incorrectly. \textbf{Note:} for a ``good'' example on this, see: \emph{Type Requirements} in \href{https://en.cppreference.com/w/cpp/algorithm/sort}{\texttt{std::sort}}.

    Another reasonable alternative, and probably the most common approach, is to implement the requirements iteratively by \emph{trial-and-error}. We just let the compiler try to instantiate the template, and the hope is that the compiler will tell us what requirements are missing, so we can implement them. Even this approach is problematic for the user. For instance, consider this snippet:

    \begin{lstlisting}
std::list l { 5, 1, 2, 4, 3 };
std::sort(l.begin(), l.end()); \end{lstlisting}

\noindent Spits around 50 lines of template instantiation errors in GCC 8.1. While this is actually pretty tame, and not that hard to figure out what's wrong, it will still scare away a lot of people. The compiler is somewhat helpful, and colors e.g. the \texttt{std::\_\_lg(\_\_last - \_\_first) * 2}, telling us that it can't compile because \texttt{std::\_List\_iterator<int>} doesn't have \texttt{operator-}. However, the most helpful hint is hidden away between those lines, and the true cause is that \texttt{std::list} uses \texttt{ForwardIterators}, and \texttt{std::sort} expects a pair of \texttt{RandomAccessIterators}. Both of these are concepts, and their requirements are defined in the standard library specification. The programmer needs to the read documentation to locate the problem anyway!

To put a little bit more salt to the wound, consider this simple example:

    \begin{lstlisting}
std::set<Widget> w; // defined as struct Widget {  }; elsewhere
w.insert(Widget{}); \end{lstlisting}

\noindent Gives around 412 lines of template instantiation errors. This is still pretty tame in comparison to what some templated libraries output when you make a small mistake, and some of the longer errors even crash terminal emulators. Why can't we just get the same quality of errors as with non-templated code?

There is a reason why compilers can't be more helpful in these situations. As I've mentioned before, unconstrained templates only validate syntax \emph{after} the template has been instantiated, which means it's very hard to track down the source of the problem. Especially if the instantiation error happens far from the ``call site'', resulting in a long \emph{template instantiation stack}. It's so hard in fact, that compilers don't even needed to provide any diagnostics for these problems (according to the standard). Luckily, compilers still try, but the chances for these error messages getting vastly better in future compiler versions are slim, since these problems are equivalent to the \emph{halting problem}.

It seems we've hit a dead-end with unconstrained templates. Maybe we'll just have to endure the pain of using templated code, or consider it a rite of passage for every \Cpp\ programmer that wishes to venture forth. We'll just have to live with fragile template interfaces and unintuitive error messages...

    \subsubsection*{Concepts to the Rescue!}

    Don't fear, concepts is here! Below we have the \texttt{average} from before, with the exception of lines 2-4, which have been squeezed in-between the template parameter list and the function signature. These apply \emph{type constraints} on \texttt{T}, which are just a set of \emph{predicates} that must be \emph{fulfilled} \underline{before} instantiation.

    Without getting boggled down on syntax (we'll have plenty of that later), lines 2-4 say that: we require \texttt{T} to be \texttt{DefaultConstructible}, \texttt{T} must also be \texttt{SummableWith} another \texttt{T}, and \texttt{T} has to be \texttt{ScalableWith} a \texttt{double}. All of these concepts together constrain \texttt{T} to a set of types we want to allow.

    \lstinputlisting[linerange={7-18}]{examples/average.cc}

    \noindent Even though that seems pretty neat, what have we gained from doing this? Apart from the extra verboseness, function authors now need to spend  time thinking about the constraints on \texttt{T}, which might seem like ``a waste of time''. After all, it's not like there aren't implicit ``constraints'' already defined in the body of the function: giving a ``bad'' \texttt{T} won't compile, even without concepts. There needs to be a good reason \emph{why} this extra verboseness is needed at all!

    Luckily, this extra verboseness solves a lot of the problems we've described, and easily outweigh the cost of having to write a couple of extra lines of code. Because the constraints on \texttt{T} are checked \emph{before} instantiation occurs, a more reasonable error message can be displayed instead of the ``junk'' we get today. Also, because constraints are part of the function signature, the interface is no longer fragile, and the user can see what concepts they need to implement.

    This completely eliminates the need to document template requirements, because the constraints are explicitly stated in the function signature. Also, the ``trial-and-error'' approach to implementing requirements is no longer unreasonable, because the compiler can now give (more) useful information! Calling \texttt{std::sort} with a \texttt{std::list} will now give something similar to: \emph{``constraints not satisfied: \texttt{std::list::iterator} is not \texttt{RandomAccess}''}, followed by a concise summary of all the requirements you need to implement.

    Also, concepts allow us to overload function templates using constraints. However, we've been able to do that for a while now, by using \emph{type traits} and SFINAE, or even with \emph{tag dispatching}. In fact, both of these are ``competitors'' to concepts, and fill similar niches. Let's have a look at both of these as well!

\subsection{Type Traits and SFINAE} \label{sec:type_traits_and_sfinae}

    \begin{table}[h]
    \begin{tabular}{ccc}
        \toprule
        \bf{Expression} & \bf{Return Type} & \bf{Requirement Specification} \\
        \midrule
        \texttt{x == y} & \textbf{\texttt{bool}} convertible & \makecell[l]{\texttt{==}\, is an equivalence relation, that is,\\
                                                                it has the following properties:\\
                                                                $\rightarrow$ for all \texttt{x}, \texttt{x == x}\\
                                                                $\rightarrow$ if \texttt{x == y}, then \texttt{y == x}\\
                                                                $\rightarrow$ if \texttt{x == y}, \texttt{y == z}, then \texttt{x == z}} \\
        \bottomrule
    \end{tabular}
    \end{table}

    \lstinputlisting[linerange={6-13}]{examples/sfinae.hh}

    \lstinputlisting[linerange={57-61}]{examples/concepts.h}

    \lstinputlisting[linerange={8-22}]{examples/factory.hh}

    \lstinputlisting[linerange={28-44}]{examples/factory.hh}

    \lstinputlisting[linerange={50-62}]{examples/factory.hh}

\subsection{Tag Dispatching} \label{sec:tag_dispatching}

    \lstinputlisting[linerange={13-31}]{examples/advance.cc}

    \lstinputlisting[linerange={36-40}]{examples/advance.cc}

    \lstinputlisting[linerange={47-50,52-59,61-62}]{examples/advance.cc}
