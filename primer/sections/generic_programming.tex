\section{Generic Programming} \label{sec:generic_programming}

Ever since the humble beginnings of \Cpp\ there's been extensive support for different kinds of \emph{polymorphism}, which can be split into two ``main'' categories: \emph{run-time} polymorphism and \emph{compile-time} polymorphism. The former is a key component in class-based OOP, and takes the form of inheritance, while the latter one enables \emph{generic programming}, and is synonymous with \emph{templates}.

Templates are a bit special in \Cpp\ since they are \emph{unconstrained}. Meaning, when we \emph{instantiate} e.g. function templates, the compiler will first generate the function (that's the instantiation part) by replacing \texttt{T} with whatever type you've passed to the function, and only \underline{after}, check if the syntax is correct! This leads to some very unfortunate side-effects, as you'll see soon enough :)

But before digging into the gritty details on that, let's start with a simple example of ``regular programming'' (i.e. with no templates), which we'll then use to iteratively build a scenario where generic programming will be needed. This will help us understand the though process that goes into designing a generic function, and how \emph{requirements} are gathered by the function's author.

Below is a function that calculates the arithmetic mean by taking in two pointers to a C-style array of \texttt{doubles}, one for the first, and last elements. Notice, that even if we would mangle the names, we would still recognize this as the \texttt{mean}, since the operations (summing elements and dividing by size), would still be familiar to us, since we know what \texttt{\{\}}, \texttt{+=}, \texttt{/} do to \texttt{doubles}.

\lstinputlisting[linerange={3-10}]{examples/mean.cc}

\noindent By using \emph{operator overloading}, we can make our user-defined types behave just like built-in types. This is very powerful, because it allows us to transfer our knowledge about e.g. \texttt{doubles}, and apply it for our own types as well, by using the \underline{\emph{same syntax}} as before. This last part is particularly important!

\lstinputlisting[linerange={6-16}]{examples/point2.hh}

\lstinputlisting[linerange={5-12}]{examples/centroid.cc}



\noindent As can be seen above, providing all those overloads to \texttt{point2} proved fruitful, since we can now represent the algorithm to find the centroid of a cluster of points in a very natural way, quite similarly to how we did the \texttt{mean} function. In fact, this function is \emph{exactly} the same as \texttt{mean}, with the only difference being that the type \texttt{double} $\rightarrow$ \texttt{point2} and that now \texttt{mean} $\rightarrow$ \texttt{centroid}. Surely there must be a way to generalize this type of ``coincidence'' in \Cpp? If you've done any GP at all before, you probably know where this is going!

\vspace{1em}\noindent\textbf{Note:} these are \underline{not} good examples on how you should write these functions, for instance, what happens when \texttt{begin >= end}? And why use pointers? Many examples in this primer are like this too, so don't use it in production!

\subsection{Unconstrained Templates} \label{sec:unconstrained_templates}

    Obviously, both \texttt{mean} and \texttt{centroid} are trying to find an \texttt{average}, which we can express as a higher-level idea with \emph{function templates}, as shown below. We've essentially just swapped \texttt{double}/\texttt{point2} by \texttt{T}, a \emph{template parameter}. These are defined in \emph{template parameter lists}, which have either \emph{type} or \emph{non-type template parameters}. By default, template parameters are \emph{unconstrained}, which means they may take \emph{any} type or value (using non-type parameters).

    Now, assume you're a user of this function, and wish to use it with your own user-defined type. What are the \emph{requirements} our type needs to \emph{satisfy}? As authors of this function, we know \texttt{T} needs to be \texttt{DefaultConstructible} in line 4, \texttt{Summable} with \texttt{T} in line 7, and \texttt{Scalable} by \texttt{double} in line 8. However, the user doesn't know that, and there's no way to tell by looking at the function signature... Do we have to go and look at the implementation?

    While that might work for this short toy example, it certainly won't scale. A possible solution (adopted by the STL) is to document everything on paper.

    \lstinputlisting[linerange={7-7,11-18}]{examples/average.cc}

    \begin{lstlisting}
std::list l { 5, 1, 2, 4, 3 };
std::sort(l.begin(), l.end()); \end{lstlisting}

\noindent Spits around 50 lines of template instantiation errors in GCC 8.1. While this is actually pretty tame, and not that hard to figure out what's wrong, it will still scare away a lot of people. The compiler is somewhat helpful, and colors e.g. the \texttt{std::\_\_lg(\_\_last - \_\_first) * 2}, telling us that it can't compile because \texttt{std::\_List\_iterator<int>} doesn't have \texttt{operator-}. However, the most helpful hint is hidden away between those lines, and the true cause is that \texttt{std::list} uses \texttt{ForwardIterators}, and \texttt{std::sort} expects a pair of \texttt{RandomAccessIterators}. Both of these are concepts, and their requirements are defined in the standard library specification. The programmer actually needs to the \underline{read} documentation to locate the problem!

To put a little bit more salt to the wound, consider this simple example:

    \begin{lstlisting}
struct Widget {  };
std::set<Widget> w;
w.insert(Widget{}); \end{lstlisting}

\noindent Gives around 412 lines of template instantiation errors. This is still pretty tame in comparison to what some templated libraries output when you make a small mistake, and some of the longer errors even crash terminal emulators. Why can't we just get the same quality of errors as with non-templated code?

There is a reason why compilers can't be more helpful in these situations. As I've mentioned before, unconstrained templates only validate syntax \emph{after} the template has been instantiated, which means it's very hard to track down the source of the problem. Especially if the instantiation error happens far from the ``call site'', resulting in a long \emph{template instantiation stack}. It's so hard in fact, that compilers don't even needed to provide any diagnostics for these problems (according to the standard). Luckily, compilers still try, but the chances for these error messages getting vastly better in future compiler versions are slim, since these problems are equivalent to the \emph{halting problem}.

It seems we've hit a dead-end with unconstrained templates. Maybe we'll just have to endure the pain of using templated code, or consider it a rite of passage for every \Cpp\ programmer that wishes to venture forth. We'll just have to live with fragile template interfaces and unintuitive error messages...

\newpage

    \lstinputlisting[linerange={7-18}]{examples/average.cc}

\subsection{Type Traits and SFINAE} \label{sec:type_traits_and_sfinae}

    \begin{table}[h]
    \begin{tabular}{ccc}
        \toprule
        \bf{Expression} & \bf{Return Type} & \bf{Requirement Specification} \\
        \midrule
        \texttt{x == y} & \textbf{\texttt{bool}} convertible & \makecell[l]{\texttt{==}\, is an equivalence relation, that is,\\
                                                                it has the following properties:\\
                                                                $\rightarrow$ for all \texttt{x}, \texttt{x == x}\\
                                                                $\rightarrow$ if \texttt{x == y}, then \texttt{y == x}\\
                                                                $\rightarrow$ if \texttt{x == y}, \texttt{y == z}, then \texttt{x == z}} \\
        \bottomrule
    \end{tabular}
    \end{table}

    \lstinputlisting[linerange={6-13}]{examples/sfinae.hh}

    \lstinputlisting[linerange={57-61}]{examples/concepts.h}

    \lstinputlisting[linerange={8-22}]{examples/factory.hh}

    \lstinputlisting[linerange={28-44}]{examples/factory.hh}

    \lstinputlisting[linerange={50-62}]{examples/factory.hh}

\subsection{Tag Dispatching} \label{sec:tag_dispatching}

    \lstinputlisting[linerange={13-31}]{examples/advance.cc}

    \lstinputlisting[linerange={36-40}]{examples/advance.cc}

    \lstinputlisting[linerange={47-50,52-59,61-62}]{examples/advance.cc}
