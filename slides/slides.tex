\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{algorithmic}
\usepackage{algorithm}
\usepackage{booktabs}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{courier}
\usepackage{tikz}
\usepackage{soul}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{makecell}
\usepackage{mathtools}
\usepackage[font={small},
            labelfont={color=black}]{caption}
\usetheme{Rochester}

\usefonttheme[onlymath]{serif}
\beamertemplatenavigationsymbolsempty
\setbeamertemplate{caption}[numbered]
\title{\Large{\textbf{A C\texttt{++} Concepts Primer:}}\\
       \large{\emph{defining and applying constraints}}}
\author{\vspace{2ex}\\
        \textbf{Erik Sven Vasconcelos Jansson}\\
        {\href{mailto:erik.s.v.jansson@tum.de}
        {\texttt{<erik.s.v.jansson@tum.de>}}} \\
        {at Technical University of Munich}}

\lstset{basicstyle=\footnotesize\ttfamily,
        breakatwhitespace = false,
        breaklines = true,
        keepspaces = true,
        language = C++,
        showspaces = false,
        showstringspaces = false,
        frame = tb,
        numbers = left,
        numbersep = 5pt,
        xleftmargin = 16pt,
        framexleftmargin = 16pt,
        belowskip = \bigskipamount,
        aboveskip = \bigskipamount,
        escapeinside={<@}{@>},
        morekeywords = {
            concept,
            requires,
            point2,
            T, U, V
        }}

\usepackage{etoolbox}
\makeatletter
\patchcmd{\endbeamer@frameslide}{\ifx\beamer@frametitle\@empty}{\iffalse}{}{\errmessage{failed to patch}}
\makeatother

\addtobeamertemplate{frametitle}{}{%
\begin{tikzpicture}[remember picture,overlay]
\node[anchor=north east,yshift=-7pt,xshift=-5pt] at (current page.north east) {\includegraphics[height=0.7cm]{figures/tulogo}};
\end{tikzpicture}}

\setbeamerfont{bibliography item}{size=\tiny}
\setbeamerfont{bibliography entry author}{size=\tiny}
\setbeamerfont{bibliography entry title}{size=\tiny}
\setbeamerfont{bibliography entry location}{size=\tiny}
\setbeamerfont{bibliography entry note}{size=\tiny}
\renewcommand*{\thefootnote}{\fnsymbol{footnote}}
\setbeamertemplate{footline}[frame number]

\makeatletter
\let\@@magyar@captionfix\relax
\makeatother

\begin{document}
    \frame{\titlepage}
    \begin{frame}[fragile]{Presentation Outline}
        \begin{columns}
        \column{0.52\textwidth}
            \begin{enumerate}
                \item Generic programming in C\texttt{++} \begin{itemize}
                    \item{\underline{unconstrained} templates.}
                \end{itemize}
                \item Problems and some solutions \begin{itemize}
                    \item{read the documentation,}
                    \item{type traits plus SFINAE,}
                    \item{... arcane ``magic'' code.}
                \end{itemize}
                \item How \textbf{Concepts Lite} improve \begin{itemize}
                    \item{\textcolor{red}{\st{un}}\underline{constrained} templates.}
                \end{itemize}
            \item \emph{Applying concept constraints} \begin{itemize}
                    \item using \texttt{requires} clause,
                    \item overload with constraint,
                    \item operations on constraint.
                \end{itemize}
            \end{enumerate}
        \column{0.48\textwidth}
            \begin{enumerate}
                \setcounter{enumi}{4}
                \item \emph{Defining list of constraints} \begin{itemize}
                    \item \texttt{requires} expressions, \begin{itemize}
                        \item simple,
                        \item type,
                        \item compound,
                        \item nested.
                    \end{itemize}
                    \item requirement\, evaluation,
                    \item naming with \texttt{concept},
                    \item defining good concepts.
                \end{itemize}
                \item Natural or in-place syntax?
                \item Ranges \& Concepts library
                \item Summary, post-Rapperswil
            \end{enumerate}
        \end{columns}
    \end{frame}

    \begin{frame}[fragile]{Generic Programming}
    \end{frame}

    \begin{frame}[fragile]{}
        \framesubtitle{Generic Programming}
        \begin{center}
        \begin{lstlisting}[caption={a ``mysterious'' function; can you figure out what this code is?}]
double f(const double* p,
         const double* const q) {
    double x {  };
    const double s = q - p;
    while (p != q)
        x += *p++;
    return x / s;
} \end{lstlisting}
        \end{center}
    \end{frame}

    \begin{frame}[fragile]{}
        \framesubtitle{Generic Programming}
        \begin{center}
        \begin{lstlisting}[caption={boilerplate for the next example; a very incomplete point class.}]
struct point2 {
    double x, y;
    point2& operator+=(const point2& p);
};

point2& point2::operator+=(const point2& p) {
    x += p.x;
    y += p.y;
    return *this;
}

point2 operator/(const point2& p, double s) {
    return { p.x / s, p.y / s };
} \end{lstlisting}
        \end{center}
    \end{frame}

    \begin{frame}[fragile]{}
        \framesubtitle{Generic Programming}
        \begin{center}
        \begin{lstlisting}[caption={another mysterious, yet strangely familiar function (déjà vu?).}]
point2 f(const point2* p,
         const point2* const q) {
    point2 x {  };
    const double s = q - p;
    while (p != q)
        x += *p++;
    return x / s;
} \end{lstlisting}
        \end{center}
    \end{frame}

    \begin{frame}[fragile]{}
        \framesubtitle{Generic Programming}
        \begin{center}
            \begin{lstlisting}[caption={natural generalization of the function from the previous slides.}]
template<typename T>
T mean(const T* begin,
       const T* const end) {
    T sum {  };
    const double size = end - begin;
    while (begin != end)
        sum += *begin++;
    return sum / size;
} \end{lstlisting}
        \end{center}
    \end{frame}

    \begin{frame}[fragile]{}
        \framesubtitle{Generic Programming}
        \begin{center}
        \begin{lstlisting}[caption={constraining the function template using a \texttt{requires} clause.}]
template<typename T> requires DefaultConstructible<T>
                              && SummableWith<T,T> &&
                              ScalableWith<T, double>
T mean(const T* begin,
       const T* const end) {
    T sum {  };
    const double size = end - begin;
    while (begin != end)
        sum += *begin++;
    return sum / size;
} \end{lstlisting}
        \end{center}
    \end{frame}

    \begin{frame}{}
        \begin{center}
        \begin{table}
        \begin{tabular}{ccc}
            \toprule
            \bf{Expression} & \bf{Return Value is} & \bf{Requirements Specification} \\
            \midrule
            \texttt{x == y} & \texttt{bool} convertible & \makecell[l]{\texttt{==}\, is an equivalence relation,\\
                                                                       that is, satisfies the following:\\
                                                                       $\rightarrow$ for all \texttt{x}, \texttt{x == x} is satis.,\\
                                                                       $\rightarrow$ if \texttt{x == y}, then \texttt{y == x},\\
                                                                       $\rightarrow$ if \texttt{x == y}, and\; \texttt{y == z},\\
                                                                       \;\;\;\, then \texttt{x == z}, follows too.
                                                                       } \\
            \bottomrule
        \end{tabular}
        \caption{\texttt{EqualityComparable} requirements from the C\texttt{++} standard.}
        \end{table}
        \end{center}
    \end{frame}

    \begin{frame}[fragile]{}
        \begin{center}
        \begin{lstlisting}[caption={\texttt{EqualityComparable} concept which ``satisfies''\footnote{not really; see the Ranges TS, this is \texttt{WeaklyEqualityComparable} \texttt{:)}} Table 1}.]
template<typename T, typename U>
concept EqualityComparable = requires(T x, U y) {
    { x == y } -> bool;
    { x != y } -> bool;
    { y != x } -> bool;
    { y == x } -> bool;
}; \end{lstlisting}
        \end{center}
    \end{frame}

    \frame{\frametitle{Questions?}}
    \begin{frame}{References}
        \nocite{*}
        \bibliographystyle{alpha}
        \bibliography{slides}
    \end{frame}
\end{document}
